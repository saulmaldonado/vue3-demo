<div id="app"></div>

<script>
  // My example at recreating render and mounting functions

  /*
   * Render function
   * generates the DOM tree
   */
  const h = (tag, props, children) => {
    return {
      tag,
      props,
      children,
    };
  };

  // mounts the dom to the app node
  const mount = (vnode, container) => {
    // creates new node
    const element = (vnode.el = document.createElement(vnode.tag));

    // if any, props are added to the new node
    if (vnode.props) {
      for (let prop in vnode.props) {
        element.setAttribute(prop, vnode.props[prop]);
      }
    }

    // if any, children are added to the node
    if (vnode.children) {
      // if children is text, add to innerText of node
      if (typeof vnode.children === 'string') {
        element.innerText = vnode.children;
      } else {
        // if children is an array, recursively add every nested node
        for (let i = 0; i < vnode.children.length; i++) {
          mount(vnode.children[i], element);
        }
      }
    }

    // mounts node to root node
    container.appendChild(element);
  };

  const vdom1 = h('div', { class: 'red' }, [h('span', null, 'hello')]);
  /**
   * result
   * <div id="app">
   *   <div class="red">hello</div>
   * </div>
   */
  mount(vdom1, document.getElementById('app'));

  //create function that will compare and the two tree and make the changes needed
  function patch(n1, n2) {
    const originalEl = n1.el;
    //check for a different tag

    if (n1.tag === n2.tag) {
      // check for props, props maybe null for either vnode
      const oldProps = n1.props ?? {};
      const newProps = n2.props ?? {};

      // diff the two objects
      for (let key in newProps) {
        let oldProp = oldProps[key];
        let newProp = newProps[key];

        if (oldProp !== newProp) {
          originalEl.setAttribute(key, newProp);
        }
      }

      //compare the children of both node
      let oldChildren = n1.children;
      let newChildren = n2.children;

      // for this case, both children are strings
      if (typeof oldChildren === 'string') {
        // if both are string, simply replace text
        if (typeof newChildren === 'string') {
          if (oldChildren !== newChildren) {
            originalEl.innerText = newChildren;
          }
        } else {
          // if the type of newChildren is an array, empty the text and replace the text by appending the new elements to the parent
          originalEl.innerText = '';
          newChildren.forEach((node) => {
            mount(node, originalEl);
          });
        }
      } else if (typeof newChildren === 'string') {
        // replace nested children with new string
        originalEl.innerText = newChildren;
      } else {
        // diff the children of both elements
        let commonLength = Math.min(oldChildren.length, newChildren.length);

        for (let i = 0; i < commonLength; i++) {
          console.log(oldChildren[i], newChildren[i]);

          patch(oldChildren[i], newChildren[i]);
        }
        // in the case children of the new node has additional children. Append them to the parent
        if (newChildren.length > oldChildren.length) {
          let extraLength = newChildren.length - commonLength;

          for (let i = 0; i < extraLength; i++) {
            mount(newChildren[i], originalEl);
          }
        }
      }
    } else {
      // if the node has a different tag, the entire node must be replaced.
      // method document.replaceNode is not supported by any browser
      let parent = originalEl.parentElement;
      parent.removeChild(originalEl);
      mount(n2, parent);
    }
  }

  /* Cases */

  // const vdom2 = h('div', { class: 'red' }, [h('span', null, ['changed!'])]);

  /**
   * result
   * <div id="app">
   *   <div class="red">changed!</div>
   * </div>
   */

  //-------------------------------------------------------------------------------------------------------

  // const vdom2 = h('div', { class: 'red' }, [
  //   h('div', null, [h('span', null, 'changed!'), h('span', null, 'changed!2')]),
  // ]);

  // result
  /**
   *
   * <div id="app">
   *    <div class="red">
   *      <div>
   *        <span>changed! 1</span>
   *        <span>changed! 2</span>
   *      </div>
   *    </div>
   * </div>
   */

  //-------------------------------------------------------------------------------------------------------

  // const vdom2 = h('div', { class: 'red' }, [h('div', null, [h('span', null, 'changed!')])]);
  /**
   * result
   * <div id="app">
   *    <div class="red">
   *      <div>
   *        <span>changed! 1</span>
   *      </div>
   *    </div>
   * </div>
   */

  //-------------------------------------------------------------------------------------------------------

  patch(vdom1, vdom2);
</script>
